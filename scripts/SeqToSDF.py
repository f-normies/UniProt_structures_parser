#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on Sun Aug 14 18:05 2022

This script converts csv table to a Structure Data File (SDF)
input - json config. see - https://github.com/SmirnygaTotoshka/SequenceToSDF

@author: SmirnygaTotoshka

@version 1.1

"""


import argparse
import json
import os
import traceback
import multiprocessing
import time
import sys
import pandas as pd
from rdkit import Chem

alphabets = {"protein" : list("ACDEFGHIKLMNPQRSTVWY"),
             "DNA" : list("ATGC"),
             "RNA" : list("AUGC")}

def isCorrectSequence(sequence, alphabet):
    seq = sequence.strip()
    for i in range(0,len(seq)):
        if seq[i] not in alphabet:
            return False
    return True

def chargePeptide(mol):
    carboxyl = Chem.MolFromSmarts('C(=O)O')# aspartate and glutamate
    lysine = Chem.MolFromSmarts('C(CCN)C[C@@H](C(=O))')
    imydazoline = Chem.MolFromSmarts('c1cnc[nH]1') # histidine
    guanidine = Chem.MolFromSmarts('NC(N)=N') # arginine

    mol.GetAtomWithIdx(0).SetFormalCharge(1) # charge N end of peptide

    carboxyl_groups_pos = list(mol.GetSubstructMatches(carboxyl))

    if len(carboxyl_groups_pos) != 0:
        for g in carboxyl_groups_pos:
            atoms_pos = list(g)
            mol.GetAtomWithIdx(atoms_pos[2]).SetFormalCharge(-1)

    lysine_groups_pos = list(mol.GetSubstructMatches(lysine))

    if len(lysine_groups_pos) != 0:
        for g in lysine_groups_pos:
            atoms_pos = list(g)
            mol.GetAtomWithIdx(atoms_pos[3]).SetFormalCharge(1)

    imydazoline_groups_pos = list(mol.GetSubstructMatches(imydazoline))

    if len(imydazoline_groups_pos) != 0:
        for g in imydazoline_groups_pos:
            atoms_pos = list(g)
            mol.GetAtomWithIdx(atoms_pos[4]).SetFormalCharge(1)

    guanidine_groups_pos = list(mol.GetSubstructMatches(guanidine))

    if len(guanidine_groups_pos) != 0:
        for g in guanidine_groups_pos:
            atoms_pos = list(g)
            mol.GetAtomWithIdx(atoms_pos[3]).SetFormalCharge(1)

def write(proc, partition, output, sequence_column, isCharged, alphabet, output_filename):
    out = os.path.join(output, output_filename + "_thread_" + str(proc) + ".sdf")
    log = os.path.join(output, output_filename + "_thread_" + str(proc) + "_log" + ".txt")
    fail = os.path.join(output, output_filename + "_thread_" + str(proc) + "_failed" + ".txt")

    written_sequences = set()

    try:
        with open(out, "w", encoding="utf-8") as o, open(log, "w", encoding="utf-8") as l, open(fail, "w", encoding="utf-8") as f:
            l.write("Start thread #" + str(proc) + " " + str(time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime())) + '\n' + "-------------------------------------------------\n")
            for i in partition.index:
                try:
                    sequence = partition.loc[i, sequence_column].strip()
                    l.write("Convert record #" + str(i) + " " + str(time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime())) + "\n")

                    if sequence in written_sequences:  # Check whether the sequence is in the set of written sequences
                        l.write("DUPLICATE! Skipping sequence #" + str(i) + "\n")
                        continue

                    if isCorrectSequence(sequence, alphabets[alphabet]):
                        if alphabet == "protein":
                            flavor = 0
                        elif alphabet == "DNA":
                            flavor = 2
                        else:
                            flavor = 6

                        molecule = Chem.MolFromSequence(sequence, flavor=flavor)
                        molecule.SetProp('_Name', sequence)
                        molecule.SetProp('MolFileInfo', "Generated by the script of A. Smirnov, Dept. Bioinformatics, Pirogov RNRMU.")
                        if isCharged and alphabet == "protein":
                            chargePeptide(molecule)

                        o.write(Chem.MolToMolBlock(molecule, forceV3000=True) + "\n")
                        for c in partition.columns:
                            if c != sequence_column:
                                o.write(">  <" + c + ">\n")
                                o.write(str(partition.loc[i, c]) + "\n\n")
                        o.write("$$$$\n")
                        l.write("SUCCESS!\n")
                        written_sequences.add(sequence)
                    else:
                        l.write("FAILED!\n")
                        f.write(str(i) + "\t" + sequence + "\n")
                except Exception as er:
                    l.write("Exception on record #" + str(i) + "\t" + sequence + "\n")
                    l.write(str(er) + "\n")
                    f.write(str(i) + "\t" + sequence + "\n")
                    traceback.print_exc()
                finally:
                    l.write("-------------------------------------------------\n")
    except Exception as e:
        print("Something went wrong in thread #" + str(proc) + "\n")
        traceback.print_exc()
        sys.exit(1)

if __name__ == '__main__':

    '''
        Path to config file
    '''
    start_time = time.time()
    parser = argparse.ArgumentParser()
    parser.add_argument("config", help="Path to config file.")
    args = parser.parse_args()

    config = args.config

    if os.path.exists(config):
        try:
            with open(config,"r") as cfg:

                '''
                    Parsing arguments
                '''
                parameters = json.loads(''.join(cfg.readlines()))

                input = parameters["input"]
                output = parameters["output"]
                sequence_column = parameters["column"]

                if "charged" in parameters.keys():
                    isCharged = parameters["charged"]
                else:
                    isCharged = False

                if "alphabet" in parameters.keys():
                    alphabet = parameters["alphabet"]
                else:
                    alphabet = "protein"

                if "threads" in parameters.keys():
                    number_threads = parameters["threads"]
                else:
                    number_threads = 1

                if "separator" in parameters.keys():
                    separator = parameters["separator"]
                else:
                    separator = ";"

                if "filename" in parameters.keys():
                    output_filename = parameters["filename"]
                else:
                    output_filename = os.path.splitext(os.path.basename(input))[0]
                    
                if "delete_tmp" in parameters.keys():
                    delete_tmp = parameters["delete_tmp"]
                else:
                    delete_tmp = True

                '''
                      Validate arguments
                '''

                if not os.path.exists(input) or not os.path.isfile(input):
                    raise BaseException("Input file doesn`t exist or it isn`t file.")
                else:
                    table = pd.read_csv(input, sep=separator, header=0, na_values="", keep_default_na=False)
                    if sequence_column not in table.columns:
                        raise BaseException("Table doesn`t contain such column.")

                if not os.path.exists(output):
                    raise BaseException("Output directory doesn`t exist.")

                if type(isCharged) != bool:
                    raise BaseException("Which type amino acids residues it should use?")

                if alphabet not in alphabets.keys():
                    raise BaseException("Invalid alphabet. Allow only " + str(list(alphabets.keys())))

                if number_threads < 1 or number_threads > 2 * multiprocessing.cpu_count():
                    raise BaseException("Too many threads. Please use from 1 to " + str(2 * multiprocessing.cpu_count()) + " threads.")

            total = len(table.index)
            number_threads = min(number_threads, total)
            size_part = total // number_threads
            size_last_part = size_part + (total - size_part * number_threads)

            # procs - количество ядер
            # calc - количество операций на ядро

            processes = []

            # делим вычисления на количество ядер
            for proc, start in zip(range(number_threads), range(0, total, size_part)):
                if proc == number_threads - 1:
                    partition = table[start:start + size_last_part]
                else:
                    partition = table[start:start + size_part]

                p = multiprocessing.Process(target=write, args=(proc, partition, output, sequence_column, isCharged, alphabet, output_filename))
                processes.append(p)
                p.start()

            # Ждем, пока все ядра
            # завершат свою работу.
            for p in processes:
                p.join()

            # Merge all

            sdf = os.path.join(output, output_filename + ".sdf")
            total_log = os.path.join(output, output_filename + "_log" + ".txt")
            total_fail = os.path.join(output, output_filename + "_failed" + ".txt")
            with open(sdf, "w", encoding="utf-8") as final, open(total_log, "w", encoding="utf-8") as log, open(total_fail, "w",encoding="utf-8") as failed:
                for i in range(number_threads):
                    out_t = os.path.join(output, output_filename + "_thread_" + str(i) + ".sdf")
                    log_t = os.path.join(output, output_filename + "_thread_" + str(i) + "_log" + ".txt")
                    fail_t = os.path.join(output, output_filename + "_thread_" + str(i) + "_failed" + ".txt")
                    with open(out_t, "r", encoding="utf-8") as o, open(log_t, "r", encoding="utf-8") as l, open(fail_t, "r", encoding="utf-8") as f:
                        final.write("".join(o.readlines()))
                        log.write("".join(l.readlines()))
                        failed.write("".join(f.readlines()))
                    if delete_tmp:
                        os.remove(out_t)
                        os.remove(log_t)
                        os.remove(fail_t)
            print("Success")
        except BaseException as e:
            print("Something went wrong\n")
            traceback.print_exc(file=sys.stdout)
            sys.exit(1)
        finally:
            end_time = time.time()
            print("--- %s seconds ---" % (end_time - start_time))
    else:
        print("Config doesn`t exist.")
        end_time = time.time()
        print("--- %s seconds ---" % (end_time - start_time))
        sys.exit(1)


